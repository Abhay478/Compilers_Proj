#include "semantic.h"



//! note: All symbol table lookups should be preceded with a lookup to the global symbol table. 
//! this means we don't have to put pointers to the thing everywhere. Phew.

/*******************
 * TYPE
********************/
Type * make_type() {
    Type * t = (Type *)calloc(1, sizeof(Type));
    return t;
}

int push_type(Type * t, VarTypes core_type, int offset, int size, void * aux) {
    InnerType * it = (InnerType *)malloc(sizeof(InnerType));
    it->core_type = core_type;
    it->offset = offset;
    it->size = size;
    it->aux = aux;
    it->next = t->head;
    t->head = it;
    return 0;
}

int typecmp(Type * t1, Type * t2) {
    InnerType * current1 = t1->head;
    InnerType * current2 = t2->head;
    while (current1 && current2) {
        if (current1->core_type != current2->core_type) {
            return 1;
        }
        if(current1->core_type == STRUCT || current1->core_type == ENUM) {
            if(current1->aux != current2->aux) {
                return 1;
            } // This is fine, as there is only one symbol table entry for each struct or enum in the global table.
        }

        if(current1->core_type == CART) {
            if(current1->size != current2->size) {
                return 1;
            }
            for(int i = 0; i < current1->size; i++) {
                InnerType * it1 = ((InnerType *)current1->aux+i);
                InnerType * it2 = ((InnerType *)current2->aux+i);
                Type nt1; nt1.head = it1;
                Type nt2; nt2.head = it2;
                if(typecmp(&nt1, &nt2)) { // Bhupendra Jogi.
                    return 1;
                }
            }
        }
        current1 = current1->next;
        current2 = current2->next;
    }
    if (current1 || current2) {
        return 1;
    }
    return 0;
}

/*******************
 * VAR
********************/

VarSymbolTableEntry * make_vste(char * name, void * value, Type * type, int offset, int size, void * aux) {
    VarSymbolTableEntry * vste = (VarSymbolTableEntry *)malloc(sizeof(VarSymbolTableEntry));
    vste->name = name;
    vste->value = value;
    vste->type = type;
    return vste;
}

int vst_insert(VarSymbolTable * st, VarSymbolTableEntry * vste) {
    for (int i = 0; i < st->size; i++) {
        if (!strcmp(st->entries[i]->name, vste->name)) {
            // Same type fine.
            if(!typecmp(st->entries[i]->type, vste->type)) {
                return 0;
            }
            return 1;
        }
    }

    if (st->size == st->capacity) {
        st->capacity = (int)(1.618 * st->capacity); // Hehe.
        st->entries = (VarSymbolTableEntry **)realloc(st->entries, st->capacity * sizeof(VarSymbolTableEntry *));
    }
    st->entries[st->size++] = vste;
    
    return 0;
}

VarSymbolTableEntry * vst_lookup(VarSymbolTable * st, char * name) {
    for (int i = 0; i < st->size; i++) {
        if (!strcmp(st->entries[i]->name, name)) {
            return st->entries[i];
        }
    }
    return NULL;
}

VarSymbolTable * make_vst() {
    VarSymbolTable * st = (VarSymbolTable *)malloc(sizeof(VarSymbolTable));
    st->size = 0;
    st->capacity = 69;
    st->entries = (VarSymbolTableEntry **)malloc(st->capacity * sizeof(VarSymbolTableEntry *));
    return st;
}   

/*******************
 * FUNC
********************/

/// @brief Generated by the function prototype, modified by the function definition. 
/// That's why the ScopeTree is NULL. 
FunctionSymbolTableEntry * make_fste(char * name, int numParams, VarSymbolTable * params) {
    FunctionSymbolTableEntry * fste = (FunctionSymbolTableEntry *)malloc(sizeof(FunctionSymbolTableEntry));
    fste->name = name;
    fste->numParams = numParams;
    fste->params = params;
    fste->locals = NULL;
    return fste;
}

FunctionSymbolTable * make_func_st() {
    FunctionSymbolTable * fst = (FunctionSymbolTable *)malloc(sizeof(FunctionSymbolTable));
    fst->size = 0;
    fst->capacity = 69;
    fst->entries = (FunctionSymbolTableEntry **)malloc(fst->capacity * sizeof(FunctionSymbolTableEntry *));
    return fst;
}

int fst_insert(FunctionSymbolTable * fst, FunctionSymbolTableEntry * fste) {
    for (int i = 0; i < fst->size; i++) {
        if (!strcmp(fst->entries[i]->name, fste->name)) {
            return 1;
        }
    }

    if (fst->size == fst->capacity) {
        fst->capacity = (int)(1.618 * fst->capacity);
        fst->entries = (FunctionSymbolTableEntry **)realloc(fst->entries, fst->capacity * sizeof(FunctionSymbolTableEntry *));
    }
    fst->entries[fst->size++] = fste;
    
    return 0;
}

FunctionSymbolTableEntry * fst_lookup(FunctionSymbolTable * fst, char * name) {
    for (int i = 0; i < fst->size; i++) {
        if (!strcmp(fst->entries[i]->name, name)) {
            return fst->entries[i];
        }
    }
    return NULL;
}

Scope * make_scope() {
    Scope * s = (Scope *)malloc(sizeof(Scope));
    s->vars = make_vst();
    s->current = NULL;
    s->parent = NULL;
    s->children = (Scope **)calloc(1, sizeof(Scope *));
    return s;
}

ScopeTree * make_scope_tree() {
    ScopeTree * st = (ScopeTree *)malloc(sizeof(ScopeTree));
    st->root = make_scope();
    return st;
}

void add_child(Scope * parent, Scope * child) {
    parent->children = (Scope **)realloc(parent->children, (parent->nch + 1) * sizeof(Scope *));
    parent->children[parent->nch++] = child;
    child->parent = parent;
}

/// @brief Provide the current scope and the current function.
VarSymbolTableEntry * scoped_lookup(FunctionSymbolTableEntry * func, Scope * s, char * name) {
    VarSymbolTableEntry * vste = vst_lookup(func->params, name);
    if(vste) {
        return vste;
    }
    Scope * current = s;
    while (current) {
        vste = vst_lookup(current->vars, name);
        if (vste) {
            return vste;
        }
        current = current->parent;
    }
    return NULL;
}

/*******************
 * STRUCT
********************/

StructSymbolTableEntry * make_struct_ste(char * name, Var ** fields, int numFields) {
    StructSymbolTableEntry * sste = (StructSymbolTableEntry *)malloc(sizeof(StructSymbolTableEntry));
    sste->name = name;
    sste->fields = fields;
    sste->numFields = numFields;
    return sste;
}

StructSymbolTable * make_struct_st() {
    // StructSymbolTable sst;
    // sst.size = 0;
    // sst.capacity = 69;
    // sst.entries = (StructSymbolTableEntry *)malloc(sst.capacity * sizeof(StructSymbolTableEntry));
    // return sst;
    StructSymbolTable * sst = (StructSymbolTable *)malloc(sizeof(StructSymbolTable));
    sst->size = 0;
    sst->capacity = 69;
    sst->entries = (StructSymbolTableEntry **)malloc(sst->capacity * sizeof(StructSymbolTableEntry *));
    return sst;
}

Type * make_struct_type(StructSymbolTableEntry * sste) {
    Type * t = (Type *)malloc(sizeof(Type));
    t->head = (InnerType *)malloc(sizeof(InnerType));
    t->head->core_type = STRUCT;
    t->head->aux = sste;
    return t;
}

int sst_insert(StructSymbolTable * sst, StructSymbolTableEntry * sste) {
    for (int i = 0; i < sst->size; i++) {
        if (!strcmp(sst->entries[i]->name, sste->name)) {
            return 1;
        }
    }

    if (sst->size == sst->capacity) {
        sst->capacity = (int)(1.618 * sst->capacity);
        sst->entries = (StructSymbolTableEntry **)realloc(sst->entries, sst->capacity * sizeof(StructSymbolTableEntry *));
    }
    sst->entries[sst->size++] = sste;
    
    return 0;
}

StructSymbolTableEntry * sst_lookup(StructSymbolTable * sst, char * name) {
    for (int i = 0; i < sst->size; i++) {
        if (!strcmp(sst->entries[i]->name, name)) {
            return sst->entries[i];
        }
    }
    return NULL;
}

/*******************
 * ENUM
********************/

EnumSymbolTableEntry * make_enum_ste(char * name, char ** fields, int numFields) {
    EnumSymbolTableEntry * este = (EnumSymbolTableEntry *)malloc(sizeof(EnumSymbolTableEntry));
    este->name = name;
    este->fields = fields;
    este->numFields = numFields;
    return este;
}

EnumSymbolTable * make_enum_st() {
    EnumSymbolTable * est = (EnumSymbolTable *)malloc(sizeof(EnumSymbolTable));
    est->size = 0;
    est->capacity = 69;
    est->entries = (EnumSymbolTableEntry **)malloc(est->capacity * sizeof(EnumSymbolTableEntry *));
    return est;
}

int est_insert(EnumSymbolTable * est, EnumSymbolTableEntry * este) {
    for (int i = 0; i < est->size; i++) {
        if (!strcmp(est->entries[i]->name, este->name)) {
            return 1;
        }
    }

    if (est->size == est->capacity) {
        est->capacity = (int)(1.618 * est->capacity);
        est->entries = (EnumSymbolTableEntry **)realloc(est->entries, est->capacity * sizeof(EnumSymbolTableEntry *));
    }
    est->entries[est->size++] = este;
    
    return 0;
}

EnumSymbolTableEntry * est_lookup(EnumSymbolTable * est, char * name) {
    for (int i = 0; i < est->size; i++) {
        if (!strcmp(est->entries[i]->name, name)) {
            return est->entries[i];
        }
    }
    return NULL;
}

/*******************
 * FORGE
********************/

ForgeSymbolTable * make_forge_st() {
    // ForgeSymbolTable fst;
    // fst.inner = make_func_st();
    // return fst;
    ForgeSymbolTable * fst = (ForgeSymbolTable *)malloc(sizeof(ForgeSymbolTable));
    fst->inner = make_func_st();
    return fst;
}

int forge_insert(ForgeSymbolTable * fst, FunctionSymbolTableEntry * fste) {
    return fst_insert(fst->inner, fste);
}

Type * get_param_type(FunctionSymbolTableEntry * f) {
    VarSymbolTable * params = f->params;
    if(params->size == 1) {
        // Only one parameter, just return it's type->
        return params->entries[0]->type;
    }

    Type * t = (Type *)malloc(sizeof(Type));
    t->head = (InnerType *)malloc(sizeof(InnerType));
    t->head->core_type = CART; // This is literally what multi-arg forges are for.

    // POTENTIAL TODO: Make claim statements use only forges.

    InnerType ** list = calloc(params->size, sizeof(InnerType *));

    for(int i = 0; i < params->size; i++) {
        list[i] = params->entries[i]->type->head;
    }

    t->head->aux = list;
    t->head->size = params->size;
    return t;
}

FunctionSymbolTableEntry * forge_lookup(ForgeSymbolTable * fst, Type * t1, Type * t2) {
    FunctionSymbolTable * f = fst->inner;
    for(int i = 0; i < f->size; i++) {
        Type * t = get_param_type(f->entries[i]);
        if((!typecmp(t, t1) && !typecmp(f->entries[i]->return_type, t2)) || (!typecmp(t, t2) && !typecmp(f->entries[i]->return_type, t1))) {
            return f->entries[i]; // A forge !
        }
    }
    return NULL;
}

/*******************
 * CLAIM
********************/

ClaimSymbolTableEntry * make_claim_ste(Type * type, Archetypes archetype) {
    ClaimSymbolTableEntry * cste = (ClaimSymbolTableEntry *)malloc(sizeof(ClaimSymbolTableEntry));
    cste->type = type;
    cste->archetype = archetype;
    return cste;
}

ClaimSymbolTable * make_claim_st() {
    ClaimSymbolTable * cst = (ClaimSymbolTable *)malloc(sizeof(ClaimSymbolTable));
    cst->size = 0;
    cst->capacity = 69;
    cst->entries = (ClaimSymbolTableEntry **)malloc(cst->capacity * sizeof(ClaimSymbolTableEntry *));
    return cst;
}

int cst_insert(ClaimSymbolTable * cst, ClaimSymbolTableEntry * cste) {
    for (int i = 0; i < cst->size; i++) {
        if (!typecmp(cst->entries[i]->type, cste->type) && cst->entries[i]->archetype == cste->archetype) {
            return 1;
        }
    }

    if (cst->size == cst->capacity) {
        cst->capacity = (int)(1.618 * cst->capacity);
        cst->entries = (ClaimSymbolTableEntry **)realloc(cst->entries, cst->capacity * sizeof(ClaimSymbolTableEntry *));
    }
    cst->entries[cst->size++] = cste;
    
    return 0;
}

ClaimSymbolTableEntry * cst_lookup(ClaimSymbolTable * cst, Type * type, Archetypes archetype) {
    for (int i = 0; i < cst->size; i++) {
        if(!typecmp(cst->entries[i]->type, type) && cst->entries[i]->archetype == archetype) {
            return cst->entries[i];
        }
    }
    return NULL;
}