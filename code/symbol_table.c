#include "semantic.h"



//! note: All symbol table lookups should be preceded with a lookup to the global symbol table. 
//! this means we don't have to put pointers to the thing everywhere. Phew.


Type make_type() {
    Type t;
    t.head = NULL;
    return t;
}

int push_type(Type * t, VarTypes core_type, int offset, int size, void * aux) {
    InnerType * it = (InnerType *)malloc(sizeof(InnerType));
    it->core_type = core_type;
    it->offset = offset;
    it->size = size;
    it->aux = aux;
    it->next = t->head;
    t->head = it;
    return 0;
}

int typecmp(Type * t1, Type * t2) {
    InnerType * current1 = t1->head;
    InnerType * current2 = t2->head;
    while (current1 && current2) {
        if (current1->core_type != current2->core_type) {
            return 1;
        }
        if(current1->core_type == STRUCT || current1->core_type == ENUM) {
            if(current1->aux != current2->aux) {
                return 1;
            } // This is fine, as there is only one symbol table entry for each struct or enum in the global table.
        }
        current1 = current1->next;
        current2 = current2->next;
    }
    if (current1 || current2) {
        return 1;
    }
    return 0;
}

VarSymbolTableEntry make_vste(char * name, void * value, Type type, int offset, int size, void * aux) {
    VarSymbolTableEntry vste;
    vste.name = name;
    vste.value = value;
    vste.type = type;
    return vste;
}

int vst_insert(VarSymbolTable * st, VarSymbolTableEntry vste) {
    for (int i = 0; i < st->size; i++) {
        if (!strcmp(st->entries[i].name, vste.name)) {
            // Same type fine.
            if(!typecmp(&st->entries[i].type, &vste.type)) {
                return 0;
            }
            return 1;
        }
    }

    if (st->size == st->capacity) {
        st->capacity = (int)(1.618 * st->capacity); // Hehe.
        st->entries = (VarSymbolTableEntry *)realloc(st->entries, st->capacity * sizeof(VarSymbolTableEntry));
    }
    st->entries[st->size++] = vste;
    
    return 0;
}

VarSymbolTableEntry * vst_lookup(VarSymbolTable * st, char * name) {
    for (int i = 0; i < st->size; i++) {
        if (!strcmp(st->entries[i].name, name)) {
            return &st->entries[i];
        }
    }
    return NULL;
}

VarSymbolTable make_vst() {
    VarSymbolTable st;
    st.size = 0;
    st.capacity = 69;
    st.entries = (VarSymbolTableEntry *)malloc(st.capacity * sizeof(VarSymbolTableEntry));
    return st;
}   

/// @brief Generated by the function prototype, modified by the function definition. 
/// That's why the ScopeTree is NULL. 
FunctionSymbolTableEntry make_fste(char * name, int numParams, VarSymbolTable * params) {
    FunctionSymbolTableEntry fste;
    fste.name = name;
    fste.numParams = numParams;
    fste.params = params;
    fste.locals = NULL;
    return fste;
}

FunctionSymbolTable make_func_st() {
    FunctionSymbolTable fst;
    fst.size = 0;
    fst.capacity = 69;
    fst.entries = (FunctionSymbolTableEntry *)malloc(fst.capacity * sizeof(FunctionSymbolTableEntry));
    return fst;
}

int fst_insert(FunctionSymbolTable * fst, FunctionSymbolTableEntry fste) {
    for (int i = 0; i < fst->size; i++) {
        if (!strcmp(fst->entries[i].name, fste.name)) {
            return 1;
        }
    }

    if (fst->size == fst->capacity) {
        fst->capacity = (int)(1.618 * fst->capacity);
        fst->entries = (FunctionSymbolTableEntry *)realloc(fst->entries, fst->capacity * sizeof(FunctionSymbolTableEntry));
    }
    fst->entries[fst->size++] = fste;
    
    return 0;
}

FunctionSymbolTableEntry * fst_lookup(FunctionSymbolTable * fst, char * name) {
    for (int i = 0; i < fst->size; i++) {
        if (!strcmp(fst->entries[i].name, name)) {
            return &fst->entries[i];
        }
    }
    return NULL;
}

Scope make_scope() {
    Scope s;
    s.vars = (VarSymbolTable *)malloc(sizeof(VarSymbolTable));
    *s.vars = make_vst();
    s.current = NULL;
    s.parent = NULL;
    s.children = (Scope **)calloc(1, sizeof(Scope *));
    return s;
}

ScopeTree make_scope_tree() {
    ScopeTree st;
    st.root = (Scope *)malloc(sizeof(Scope));
    *st.root = make_scope();
    return st;
}

void add_child(Scope * parent, Scope * child) {
    parent->children = (Scope **)realloc(parent->children, (parent->nch + 1) * sizeof(Scope *));
    parent->children[parent->nch++] = child;
    child->parent = parent;
}

/// @brief Provide the current scope and the current function.
VarSymbolTableEntry * scoped_lookup(FunctionSymbolTableEntry * func, Scope * s, char * name) {
    VarSymbolTableEntry * vste = vst_lookup(func->params, name);
    if(vste) {
        return vste;
    }
    Scope * current = s;
    while (current) {
        vste = vst_lookup(current->vars, name);
        if (vste) {
            return vste;
        }
        current = current->parent;
    }
    return NULL;
}

StructSymbolTable make_struct_st() {
    StructSymbolTable sst;
    sst.size = 0;
    sst.capacity = 69;
    sst.entries = (StructSymbolTableEntry *)malloc(sst.capacity * sizeof(StructSymbolTableEntry));
    return sst;
}

int sst_insert(StructSymbolTable * sst, StructSymbolTableEntry sste) {
    for (int i = 0; i < sst->size; i++) {
        if (!strcmp(sst->entries[i].name, sste.name)) {
            return 1;
        }
    }

    if (sst->size == sst->capacity) {
        sst->capacity = (int)(1.618 * sst->capacity);
        sst->entries = (StructSymbolTableEntry *)realloc(sst->entries, sst->capacity * sizeof(StructSymbolTableEntry));
    }
    sst->entries[sst->size++] = sste;
    
    return 0;
}

StructSymbolTableEntry * sst_lookup(StructSymbolTable * sst, char * name) {
    for (int i = 0; i < sst->size; i++) {
        if (!strcmp(sst->entries[i].name, name)) {
            return &sst->entries[i];
        }
    }
    return NULL;
}

EnumSymbolTableEntry make_enum_ste(char * name, char ** fields, int numFields) {
    EnumSymbolTableEntry este;
    este.name = name;
    este.fields = fields;
    este.numFields = numFields;
    return este;
}

EnumSymbolTable make_enum_st() {
    EnumSymbolTable est;
    est.size = 0;
    est.capacity = 69;
    est.entries = (EnumSymbolTableEntry *)malloc(est.capacity * sizeof(EnumSymbolTableEntry));
    return est;
}

int est_insert(EnumSymbolTable * est, EnumSymbolTableEntry este) {
    for (int i = 0; i < est->size; i++) {
        if (!strcmp(est->entries[i].name, este.name)) {
            return 1;
        }
    }

    if (est->size == est->capacity) {
        est->capacity = (int)(1.618 * est->capacity);
        est->entries = (EnumSymbolTableEntry *)realloc(est->entries, est->capacity * sizeof(EnumSymbolTableEntry));
    }
    est->entries[est->size++] = este;
    
    return 0;
}

EnumSymbolTableEntry * est_lookup(EnumSymbolTable * est, char * name) {
    for (int i = 0; i < est->size; i++) {
        if (!strcmp(est->entries[i].name, name)) {
            return &est->entries[i];
        }
    }
    return NULL;
}

// typedef struct ForgeSymbolTableEntry {
//     VarSymbolTable * from; // Not just a single type. A forge is a function too.
//     Type to;

// } ForgeSymbolTableEntry;

ForgeSymbolTable make_forge_st() {
    ForgeSymbolTable fst;
    fst.inner = make_func_st();
    return fst;
}

int forge_insert(ForgeSymbolTable * fst, FunctionSymbolTableEntry fste) {
    return fst_insert(&fst->inner, fste);
}

FunctionSymbolTableEntry * forge_lookup(ForgeSymbolTable * fst, char * name) {
    return fst_lookup(&fst->inner, name);
}

ClaimSymbolTableEntry make_claim_ste(char * name, Type type, Archetypes archetype) {
    ClaimSymbolTableEntry cste;
    cste.name = name;
    cste.type = type;
    cste.archetype = archetype;
    return cste;
}

ClaimSymbolTable make_claim_st() {
    ClaimSymbolTable cst;
    cst.size = 0;
    cst.capacity = 69;
    cst.entries = (ClaimSymbolTableEntry *)malloc(cst.capacity * sizeof(ClaimSymbolTableEntry));
    return cst;
}

int cst_insert(ClaimSymbolTable * cst, ClaimSymbolTableEntry cste) {
    for (int i = 0; i < cst->size; i++) {
        if (!strcmp(cst->entries[i].name, cste.name)) {
            return 1;
        }
    }

    if (cst->size == cst->capacity) {
        cst->capacity = (int)(1.618 * cst->capacity);
        cst->entries = (ClaimSymbolTableEntry *)realloc(cst->entries, cst->capacity * sizeof(ClaimSymbolTableEntry));
    }
    cst->entries[cst->size++] = cste;
    
    return 0;
}

ClaimSymbolTableEntry * cst_lookup(ClaimSymbolTable * cst, Type type, Archetypes archetype) {
    for (int i = 0; i < cst->size; i++) {
        if(!typecmp(&cst->entries[i].type, &type) && cst->entries[i].archetype == archetype) {
            return &cst->entries[i];
        }
    }
    return NULL;
}