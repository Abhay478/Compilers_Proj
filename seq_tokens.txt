reserved keyword: fn
ID: fib
special characters: (
ID: n
punctuation: :
data type: u32
special characters: )
punctuation: :
special characters: [
ID: BigInt
special characters: ]
special characters: {
reserved keyword: let
ID: a
punctuation: :
ID: BigInt
operator: =
constant: 0
punctuation: ;
reserved keyword: let
ID: b
punctuation: :
ID: BigInt
operator: =
constant: 1
punctuation: ;
reserved keyword: let
ID: out
punctuation: :
special characters: [
ID: BigInt
special characters: ]
operator: =
special characters: [
ID: a
punctuation: ,
ID: b
special characters: ]
punctuation: ;
reserved keyword: for
special characters: (
reserved keyword: let
ID: i
punctuation: :
data type: u32
operator: =
constant: 2
punctuation: ;
ID: i
operator: <
ID: n
punctuation: ;
ID: i
operator: ++
special characters: )
special characters: {
reserved keyword: let
ID: c
punctuation: :
data type: u32
operator: =
ID: a
operator: +
ID: b
punctuation: ;
ID: a
operator: =
ID: b
punctuation: ;
ID: b
operator: =
ID: c
punctuation: ;
ID: out
operator: +=
special characters: [
ID: c
special characters: ]
punctuation: ;
special characters: }
reserved keyword: return
ID: out
punctuation: ;
special characters: }
reserved keyword: struct
ID: two_tup
special characters: {
ID: val
punctuation: :
ID: BigInt
punctuation: ,
ID: aux
punctuation: :
ID: BigInt
punctuation: ,
special characters: }
reserved keyword: claim
ID: two_tup
reserved keyword: is
reserved keyword: Group
special characters: {
special characters: (
ID: c
operator: =
ID: a
operator: +
ID: b
special characters: )
operator: =>
special characters: {
ID: c
operator: .
ID: val
operator: =
ID: a
operator: .
ID: val
operator: +
ID: b
operator: .
ID: val
punctuation: ;
ID: c
operator: .
ID: aux
operator: =
ID: a
operator: .
ID: aux
operator: +
ID: b
operator: .
ID: aux
punctuation: ;
special characters: }
special characters: (
ID: c
operator: =
constant: 0
special characters: )
operator: =>
special characters: {
ID: c
operator: .
ID: val
operator: =
constant: 0
punctuation: ;
ID: c
operator: .
ID: aux
operator: =
constant: 0
punctuation: ;
special characters: }
special characters: (
ID: b
operator: =
operator: -
ID: a
special characters: )
operator: =>
special characters: {
ID: c
operator: .
ID: val
operator: =
operator: -
ID: a
operator: .
ID: val
punctuation: ;
ID: c
operator: .
ID: aux
operator: =
operator: -
ID: a
operator: .
ID: aux
punctuation: ;
special characters: }
special characters: }
reserved keyword: forge
special characters: (
ID: a
punctuation: :
ID: two_tup
special characters: )
reserved keyword: as
special characters: (
special characters: (
ID: BigInt
punctuation: ,
ID: BigInt
special characters: )
special characters: )
special characters: {
ID: b
operator: =
special characters: (
ID: a
operator: .
ID: val
punctuation: ,
ID: a
operator: .
ID: aux
special characters: )
punctuation: ;
ID: print
special characters: (
constant: "We are forging here."
special characters: )
punctuation: ;
special characters: }
reserved keyword: forge
special characters: (
ID: a
punctuation: :
special characters: (
ID: BigInt
punctuation: ,
ID: BigInt
special characters: )
special characters: )
reserved keyword: as
special characters: (
ID: two_tup
special characters: )
special characters: {
ID: b
operator: .
ID: val
operator: =
ID: a
operator: .
constant: 0
punctuation: ;
ID: b
operator: .
ID: aux
operator: =
ID: a
operator: .
constant: 1
punctuation: ;
ID: print
special characters: (
constant: "We are forging here also."
special characters: )
punctuation: ;
special characters: }
reserved keyword: forge
special characters: (
ID: a
punctuation: :
special characters: [
ID: BigInt
special characters: ]
special characters: )
reserved keyword: as
special characters: (
ID: two_tup
special characters: )
special characters: {
ID: b
operator: .
ID: val
operator: =
ID: a
special characters: [
constant: 0
special characters: ]
punctuation: ;
ID: b
operator: .
ID: aux
operator: =
ID: a
special characters: [
constant: 1
special characters: ]
punctuation: ;
ID: print
special characters: (
constant: "We are forging here again."
special characters: )
punctuation: ;
special characters: }
reserved keyword: fn
ID: main
special characters: (
special characters: )
special characters: {
ID: print
special characters: (
constant: "This is main."
special characters: )
punctuation: ;
reserved keyword: let
ID: b
punctuation: :
special characters: [
ID: BigInt
special characters: ]
operator: =
ID: fib
special characters: (
constant: 30
special characters: )
punctuation: ;
ID: print
special characters: (
ID: b
special characters: )
punctuation: ;
reserved keyword: let
ID: a
punctuation: :
ID: two_tup
operator: =
special characters: [
constant: 1
punctuation: ,
constant: 2
special characters: ]
reserved keyword: as
special characters: (
ID: two_tup
special characters: )
punctuation: ;
ID: print
special characters: (
ID: a
special characters: )
punctuation: ;
reserved keyword: let
ID: tup
punctuation: :
special characters: (
ID: BigInt
punctuation: ,
ID: BigInt
special characters: )
operator: =
ID: a
reserved keyword: as
special characters: (
special characters: (
ID: BigInt
punctuation: ,
ID: BigInt
special characters: )
special characters: )
punctuation: ;
ID: print
special characters: (
ID: tup
special characters: )
punctuation: ;
special characters: }
